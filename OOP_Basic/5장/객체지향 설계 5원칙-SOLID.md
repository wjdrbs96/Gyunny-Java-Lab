# `5장: 객체지향 설계 5원칙-SOLID`

객체지향 설계 5원칙 SOLID가 무엇일까요? 

- `SPR(Single Responsibility Principle): 단일 책임 원칙`
- `OCP(Open Closed Priciple): 개방 폐쇄 원칙`
- `LSP(Liskov Subsitiution Priciple): 리스코프 치환 원칙`
- `ISP(Interface Segregation Principle): 인터페이스 분리 원칙`
- `DIP(Dependency Inversion Principle): 의존 역전 원칙`

<br>

원칙들의 핵심은 `응집도는 높이고, 결합도는 낮추는` 것입니다. (P177 참고)

<br>

## `SPR - 단일 책임 원칙`

> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. - 로버트 C.마틴

<br>

![sss](https://postfiles.pstatic.net/20151008_74/rain483_1444230268453rD9tW_JPEG/001.jpg?type=w1)

위의 그림처럼 남자가 한번에 `남자친구, 아들, 회사원, 군인`의 역할을 하게 되면 한번에 해야할 일이 너무 많습니다. 

![srp](https://postfiles.pstatic.net/20151008_29/rain483_14442302687088ep7O_JPEG/002.jpg?type=w1)

그래서 P179 처럼 `단일 책임 원칙을 적용해서` 여러 개의 클래스로 분리하는 것입니다. 그러면 남자라는 클래스가 `역할과 책임에 따라 네 개의 클래스로 쪼개진 것을 볼 수 있습니다.`

<br>

### `속성이 SRP를 지키지 않은 경우`

```java
class 사람 {
    String 군번;
}

사람 로미오 = new 사람();
사람 줄리엣 = new 사람();

줄리엣.군번 = "1573042009"   // ? ?
```

만약 남자만 군대를 가고, 여자는 군대를 가지 않는다고 가정을 해보겠습니다. 그러면 위와 같이 줄리엣이 군번 속성에 접근하게 되는 것은 문제가 있다는 것을 알 수 있습니다. 

이 때 `단일 책임 원칙`을 적용하는 것입니다. `남자 클래스와 여자 클래스에 공통점이 없다면 사람 클래스를 제거하면 됩니다. 공통점이 많다면 사람 클래스를 상위 클래스로 해서 공통점을 사람 클래스에 두고 남자 클래스와 여자 클래스는 사람 클래스를 상속하고 차이점만 각자 구현하면 됩니다.`(P180)

<br>

이번에는 메소드가 SRP를 지키지 못한 경우에 대해서 알아보겠습니다. 

```java
class 강아지 {
    final static Boolean 수컷 = true;
    final static Boolean 암컷 = false;
    Boolean 성별;
    
    void 소변보다() {
        if (this.성별 == 수컷) {
            // 한쪽 다리를 들고 소변을 보다.
        } else {
            // 뒷다리 두 개를 굽혀 앉은 자세로 소변을 본다.
        }
    }   
}
```

위의 메소드를 보면 `강아지 클래스의 소변보다() 메소드가 수컷 강아지의 행위와 암컷 강아지의 행위를 모두 구현하려고 하기에 단일 책임(행위) 원칙을 위배하고 있는 것입니다.`
메소드가 `단일 책임 원칙을 지키지 않을 경우 나타나는 대표적인 것이 바로 분기 처리를 위한 if문 입니다.`

```java
abstract class 강아지 {
    abstract void 소변보다();
}

class 수컷강아지 extends 강아지 {
    void 소변보다() {
        // 한쪽 다리를 들고 소변을 본다.
    }
}

class 암컷강아지 extends 강아지 {
    void 소변보다() {
        // 뒷다리 두 개로 앉은 자세로 소변을 본다.
    }
}
```

위와 같이 리팩토링을 할 수 있습니다. 

`단일 책임과 가장 관계가 깊은 것은 바로 모델링 과정을 담당하는 '추상화' 과정입니다.` 

<br>

> 애플리케이션의 경계를 정하고 추상화를 통해 클래스들을 선별하고 속성과 메소드를 설계할 때 반드시 단일 책임 원칙을 고려하는 습관을 들이자. <br>
> 또한 리팩토링을 통해 코드를 개선할 때도 단일 책임 원칙을 적용할 곳이 있는지 꼼꼼히 살펴보자.

<br>

## `OCP - 개방 폐쇄 원칙`

> 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다. - 로버트 C.마틴 <br>
>
> 즉, 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.

<br>

그리고 이제 `개방 폐쇄 원칙`에 위배되는 상황에 대해서 알아보겠습니다. 

![not](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F267ADB4F569847311F0EF6)

위의 그림을 보면 기어가 `수동`일 때, `자동`일 때 운전자가 다르게 행동해야 함을 알 수 있습니다. 물론 어느정도 자동기어와 수동기어는 차이가 있지만 객체지향에서 이러한 설계는 `개방 폐쇄 원칙`에 위배가 됩니다.

![good](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F22570C4B56984767308615)

위와 같이 `상위 클래스` 또는 `인터페이스`를 중간에 둠으로써 다양한 자동차가 있어도 운전자는 영향을 받지 않을 수 있습니다. 

> 다양한 자동차가 생긴다고 하는 것은 자동차 입장에서는 자신의 확장에는 개방돼 있는 것이고, 운전자 입장에서는 주변의 변화에 폐쇄돼 있는 것이다.

<br>

### `데이터베이스의 개방 폐쇄 원칙의 아주 좋은 예`

![database](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F23714D4056984C3D3A66FC)

JDBC가 `개방 폐쇄 원칙`의 가장 좋은 예입니다. JDBC를 사용하는 클라이언트는 데이터베이스가 `오라클`에서 `MySQL`로 바뀌더라도 Connection을 설정하는 부분 외에는 따로 수정할 필요가 없습니다. 

<br>

> 개방 폐쇄 원칙을 무시하고 프로그램을 작성하면 객체지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없다. <br>
> 따라서 객체지향 프로그래밍에서 개방 폐쇄 원칙은 반드시 지켜야 할 원칙이다.

<br>

## `LSP - 리스코프 치환 원칙`

> 서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다. - 로버트 C.마틴

객체지향의 상속은 아래의 조건을 만족해야 합니다. 

- `하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.`
- `구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스 할 수 있어야 한다.`

위 두 개의 문장대로 구현된 프로그램이라면 이미 `리스코프 치환 원칙`을 잘 지키고 있다고 할 수 있습니다.

<br>

### `인터페이스 할 수 있다란?`

- `AutoCloseable - 자동으로 닫힐 수 있어야 한다.`
- `Appendable - 덧붙일 수 있어야 한다.`
- `Clonealbe - 복제할 수 있어야 한다.`
- `Runnable - 실행할 수 있어야 한다.`

<br>

### `리스코프 치환 원칙 위배`

- `아버지 - 딸(계층도/조직도)`

![family](https://mblogthumb-phinf.pstatic.net/20151009_104/rain483_1444371663229qHJsJ_JPEG/010.jpg?type=w2)

<br>

### `리프코프 치환 원칙 만족`

- `동물 - 펭귄 구조(분류도)`

![animal](https://mblogthumb-phinf.pstatic.net/20151009_15/rain483_1444371663404R3s4K_JPEG/011.jpg?type=w2)

<br>

> 즉, 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다. 

<br>

## `ISP - 인터페이스 분리 원칙`

> 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다. - 로버트 C.마틴

`단일 책임 원칙(SRP)`에서는 `하나의 역할(책임)만 하도록 다수의 클래스로 분할하였습니다`

![ISP](https://t1.daumcdn.net/cfile/tistory/99FF0A435BBEF3130B)

`인터페이스 분리 원칙`은 각 역할에 맞게 `인터페이스`로 분리하는 것입니다.(ex 어머니한테는 아들, 여자친구한테는 남자친구)

<br>

> 결론적으로는 단일 책임 원칙(SRP)과 인터페이스 분할 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다. <br>
>
> 하지만 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이라고 할 수 있다.

<br>

- `상위 클래스는 풍성할수록 좋다.`
    - 풍성할수록 하위 클래스에게 많은 기능을 확장시켜주는 것이고, 형변환, 코드 중복을 줄여줍니다.
- `인터페이스 내에 메소드는 최소한 일수록 좋다.`
    - 인터페이스는 하위 클래스에게 구현을 강제하도록 하는 역할입니다. 즉, 최소한의 기능만 제공하면서 하나의 역할에 집중하라는 뜻입니다. 
    
<br>

## `DIP - 의존 역전 원칙`

> 고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다. <br>
> 
> 추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다. <br> 
> 
> 자주 변경되는 구체(Concrete) 클래스에 의존하지 마라 - 로버트 C.마틴 -

<br>

![di](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F21784C415698700A05D93C)

자동차가 타이어에 의존하면 어떻게 될까요? 자동차 타이어는 자주 바뀌게 되는 것 중 하나입니다. 이렇게 자주 바뀌는 것에 의존하면 자동차는 영향을 받게 되어 있습니다. 

즉, 자동차 자신보다 더 자주 변하는 스노우타이어에 의존하기에 좋지 않음을 알 수 있습니다. 

![goodd](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F235E853E569870EA358109)

자동차가 구체적인 타이어가 아닌 추상화된 타이어 인터페이스에만 의존하게 함으로써 타이어가 변경되어도 자동차가 영향을 받지 않습니다. 

<br>

> 이처럼 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙이다. <br>
> 
> 상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것이 바로 의존 역전 원칙이다.

