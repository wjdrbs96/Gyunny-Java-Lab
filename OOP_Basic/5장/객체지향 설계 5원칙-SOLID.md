# `5장: 객체지향 설계 5원칙-SOLID`

객체지향 설계 5원칙 SOLID가 무엇일까요? 

- `SPR(Single Responsibility Principle): 단일 책임 원칙`
- `OCP(Open Closed Priciple): 개방 폐쇄 원칙`
- `LSP(Liskov Subsitiution Priciple): 리스코프 치환 원칙`
- `ISP(Interface Segregation Principle): 인터페이스 분리 원칙`
- `DIP(Dependency Inversion Principle): 의존 역전 원칙`

<br>

원칙들의 핵심은 `응집도는 높이고, 결합도는 낮추는` 것입니다. (P177 참고)

<br>

## `SPR - 단일 책임 원칙`

> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. - 로버트 C.마틴

<br>

![sss](https://postfiles.pstatic.net/20151008_74/rain483_1444230268453rD9tW_JPEG/001.jpg?type=w1)

위의 그림처럼 남자가 한번에 `남자친구, 아들, 회사원, 군인`의 역할을 하게 되면 한번에 해야할 일이 너무 많습니다. 

![srp](https://postfiles.pstatic.net/20151008_29/rain483_14442302687088ep7O_JPEG/002.jpg?type=w1)

그래서 P179 처럼 `단일 책임 원칙을 적용해서` 여러 개의 클래스로 분리하는 것입니다. 그러면 남자라는 클래스가 `역할과 책임에 따라 네 개의 클래스로 쪼개진 것을 볼 수 있습니다.`

<br>

### `속성이 SRP를 지키지 않은 경우`

```java
class 사람 {
    String 군번;
}

사람 로미오 = new 사람();
사람 줄리엣 = new 사람();

줄리엣.군번 = "1573042009"   // ? ?
```

만약 남자만 군대를 가고, 여자는 군대를 가지 않는다고 가정을 해보겠습니다. 그러면 위와 같이 줄리엣이 군번 속성에 접근하게 되는 것은 문제가 있다는 것을 알 수 있습니다. 

이 때 `단일 책임 원칙`을 적용하는 것입니다. `남자 클래스와 여자 클래스에 공통점이 없다면 사람 클래스를 제거하면 됩니다. 공통점이 많다면 사람 클래스를 상위 클래스로 해서 공통점을 사람 클래스에 두고 남자 클래스와 여자 클래스는 사람 클래스를 상속하고 차이점만 각자 구현하면 됩니다.`(P180)

<br>

이번에는 메소드가 SRP를 지키지 못한 경우에 대해서 알아보겠습니다. 

```java
class 강아지 {
    final static Boolean 수컷 = true;
    final static Boolean 암컷 = false;
    Boolean 성별;
    
    void 소변보다() {
        if (this.성별 == 수컷) {
            // 한쪽 다리를 들고 소변을 보다.
        } else {
            // 뒷다리 두 개를 굽혀 앉은 자세로 소변을 본다.
        }
    }   
}
```

위의 메소드를 보면 `강아지 클래스의 소변보다() 메소드가 수컷 강아지의 행위와 암컷 강아지의 행위를 모두 구현하려고 하기에 단일 책임(행위) 원칙을 위배하고 있는 것입니다.`
메소드가 `단일 책임 원칙을 지키지 않을 경우 나타나는 대표적인 것이 바로 분기 처리를 위한 if문 입니다.`

```java
abstract class 강아지 {
    abstract void 소변보다();
}

class 수컷강아지 extends 강아지 {
    void 소변보다() {
        // 한쪽 다리를 들고 소변을 본다.
    }
}

class 암컷강아지 extends 강아지 {
    void 소변보다() {
        // 뒷다리 두 개로 앉은 자세로 소변을 본다.
    }
}
```

위와 같이 리팩토링을 할 수 있습니다. 

`단일 책임과 가장 관계가 깊은 것은 바로 모델링 과정을 담당하는 '추상화' 과정입니다.` 

<br>

> 애플리케이션의 경계를 정하고 추상화를 통해 클래스들을 선별하고 속성과 메소드를 설계할 때 반드시 단일 책임 원칙을 고려하는 습관을 들이자. <br>
> 또한 리팩토링을 통해 코드를 개선할 때도 단일 책임 원칙을 적용할 곳이 있는지 꼼꼼히 살펴보자.