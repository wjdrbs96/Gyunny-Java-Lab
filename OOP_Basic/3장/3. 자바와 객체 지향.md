# `3장: 자바와 객체지향`

> "우리가 주변에서 사물을 인지하는 방식대로 프로그래밍 할 수 있지 않겠는가" 하는 것이 객체지향의 출발이다. <br>
> 0과 1로 대변되는 기계(컴퓨터)에 맞춰 사고하던 방식을 버리고 현실세꼐를 인지하는 방식으로 프로그램을 만들자는 것이다. 그래서 객체지향은 직관적이다.

<br>

## `객체지향의 4대 특성`

- `캡슐화(Encapsulation): 정보 은닉(information hiding)`
- `상속(Inheritance): 재사용`
- `추상화(Abstraction): 모델링`
- `다형성(Polymorphism): 사용 편의`

객체지향의 4대 특성은 위와 같습니다. 특성에 무엇이 있는지도 알아두고 어떤 특징이 있는지도 알아보겠습니다. 

<br>

### `클래스 vs 객체 차이는?`

- `사람은 클래스인가? 객체인가?`
- `김연아는 클래스인가? 객체인가?`
- `뽀로로는 클래스인가? 객체인가?`
- `펭귄은 클래스인가? 객체인가?`

위의 질문에 제대로 대답할 수 있다면 객체지향에 대해 어느정도 이해하고 있다 할 수 있습니다. 

위의 질문에 대해서 쉽게 구분하는 법은 `나이를 물어보는 것` 입니다. 

- `사람의 나이는 몇 살인가?`
- `김연아의 나이는 몇 살인가?`
- `뽀로로의 나이는 몇 살인가?`
- `펭귄의 나이는 몇 살인가?`

`사람`, `펭귄`의 나이에 대한 질문은 대답하기가 어려울 것입니다. 하지만 `김연아`, `뽀로로`의 나이는 검색해보면 알 수 있습니다. 그래서 `김연아`, `뽀로로`는 객체이고, `사람`, `펭귄`은 클래스입니다. 

> 즉, 클래스는 분류에 대한 개념이지 실체가 아니다. 객체는 실체다.

이제 클래스와 객체의 차이점에 대해 알아보았으니 본격적으로 `객체지향의 4대 특성`에 대해서 알아보겠습니다.

<br>

## `추상화: 모델링`

보통 얘기를 하다 보면 `추상화 했다.` 라며 `추상화`라는 단어를 자주 들었습니다. 그럴 때마다 알긴 알겠는데 설명하기는 좀 그런.. 식으로 알았는데 어떤 의미인지 알아보겠습니다.

![dsd](https://i.pinimg.com/originals/71/c8/ae/71c8aea33857c8fe3f4a3e6c9119ed01.jpg)

위의 그림은 `고대 이집트 벽화`입니다. 사진을 보면 얼굴은 측면을 보고 있는데 몸은 정면을 보고 있고 약간 특이한 것을 볼 수 있습니다. 

이렇게 그린 이유는 당시에 `권력 크기에 비례해 키를 그렸다`고 합니다. 즉, 화가는 사람의 실제 모습이 아니라 추상적인 모습을 그려서 그 인문의 특징을 더욱 정확하게 묘사하려 했던 것입니다. 

> 추상: 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용

여기서 `공통 특성/공통 속성 추출`이라는 부분에 주목해야 합니다.

<br>

## `추상화는 모델링이다.`

`추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것이라고 정리할 수 있다.`

사람이라는 클래스를 설계한다고 해보겠습니다. 설계할 때, 사람 객체들을 관찰해서 사람 객체들이 가진 공통된 특성을 찾게 됩니다.

`시력, 몸무게, 혈액형, 키, 직업, 나이 등등` 그리고 동사로는 `먹다, 자다, 일하다, 운전하다` 등등 엄청나게 많은 것들이 존재합니다. 

이러한 것들을 다 표현하면 끝이 없기 때문에 `어디에서 사용할 것인지 기준`을 정해야 합니다. 

> 내가 창조하려는 세상은 어떤 세상인가? <br>
> 내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가?

예를들어 병원 애플리케이션을 만든다면 `환자`, `의사`와 같은 사람들이 할 수 있고 가질 수 있는 속성들을 정의하면 됩니다.

<br>

> 즉, 추상화란 구체적인 것을 분해해서 관심 영역에 대한 특성만을 가지고 재조합하는 것 

이것을 좀 더 IT 용어에 맞게 변형하면 아래와 같습니다.

> 추상화란 구체적인 것을 분해해서 관심영역(애플리케이션 경계, Application Boundary)에 있는 특성만 가지고 재조합하는 것 = 모델링

<br>

`추상화는 모델링이다.`라는 말을 좀 더 살펴보겠습니다. 지구본은 지구를 표현하려고 만들었지만 정확하게 굴곡, 기후, 바다 모든 것을 표현하지는 못합니다. 

> 즉, 모델은 실제 사물을 정확히 복제하는 것이 아니라 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것이다. <br>
> 바로 모델은 추상화를 통해 실제 사물을 단순하게 묘사하는 것이다.

<br>

정리하면 아래와 같습니다.

- `OOP의 추상화는 모델링이다.`
- `클래스: 객체 = 펭귄: 뽀로로`
- `클래스 설계에서 추상화가 사용된다.`
- `클래스 설계를 위해서는 애플리케이션 경계부터 정해야 한다.`
- `객체 지향에서 추상화의 결과는 클래스이다.`

추상화의 개념을 넓게 본다면 아래 내용도 포함됩니다. 

- `상속을 통한 추상화, 구체화`
- `인터페이스를 통한 추상화`
- `다형성을 통한 추상화`

<br>

## `상속: 재사용 + 확장`

상속이라는 말을 들으면 일반적으로 가족 관계의 상속을 생각할 수 있습니다. 할아버지 - 아빠 - 나 이런식입니다. 

하지만 객체지향의 상속은 이러한 개념이 아닙니다. 즉, 객체지향의 상속은 `상속이 아닌 재사용과 확장으로 이해하는 것`이 맞습니다. 

![dhodkseho](https://lh3.googleusercontent.com/proxy/PYZcipWYbtjqqP7F-ujfQG1e5EugIIGIsCTJlpU0V3Cajukgll8kyAsgvoxeQ6fw3Z9y-U4G6eH3WRRfogSqXorQIVRsQVWtOBoCN8W-T5QjrBmlsAvWsjoWQYs7SI63dEame8zmGcEeYGHyluwD7w)

객체지향에서의 상속의 예시는 위와 같습니다. 보면 포유류의 부모는 동물이 아닙니다. 마찬가지로 고래의 부모도 포유류가 아닙니다. 

`객체지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 대해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미입니다.`

> 즉, 객체지향에서 상속이란 일반인들이 생각하는 상속이 아닌 확장, 세분화, 슈퍼클래스 - 서브클래스(상위클래스 - 하위클래스) 개념으로 이해해야 합니다.

포유류는 동물의 특성을 확장했다고 볼 수 있고, 고래도 포유류의 특성을 확장했다고 할 수 있습니다.

<br>

### `상속 관계에서 반드시 만족해야 할 문장`

- `하위 클래스는 상위 클래스다.`

이 문장을 기반으로 가족 상속 관계의 문장을 대입해보겠습니다.  

- `아버지는 할아버지다??`
- `아들은 아버지다??`
- `딸은 아버지다??`

위의 문장은 딱 보아도 어색한 것을 느낄 수 있습니다.

- `포유류는 동물이다.`
- `고래는 포유류다.`
- `고래는 동물이다.`

즉, 자바에서 `상속(inheritence)`이라는 말보다는 `확장(extends)`라는 말이 더 적합하다는 것을 알 수 있습니다.

<br>

객체지향에서 상속을 정리하면 아래와 같습니다.

- `객체지향의 상속은 상위 클래스의 특성을 재사용하는 것입니다.`
- `객체지향의 상속은 상위 클래스의 특성을 확장하는 것입니다.`
- `객체지향의 상속은 is a kind of 관계를 만족해야 합니다.`

<br>

### `자바의 인터페이스`

- `인터페이스 구현클래스 is able to 인터페이스`
- `해석: 구현클래스는 인터페이스 할 수 있다.`
- `예제: 고래는 헤어칠 수 있다.`

인터페이스는 `be able to` 즉, `무엇을 할 수 있는`이라는 형태로 만드는 것이 좋습니다. 

- `Serializable: 직렬화할 수 있는`
- `Clonable: 복제할 수 있는`
- `Comparable: 비교할 수 있는`
- `Runnable: 실행할 수 있는`

즉, 인터페이스와 상속을 요약하면 아래와 같습니다.

- `상위 클래스는 하위 클래스에게 특성(속성과 메소드)을 상속`
    - 상위 클래스는 물려줄 특성이 풍성할수록 좋다. (LSP - 리스코프 치환 원칙)
- `인터페이스는 클래스가 '무엇을 할 수 있다'라고 하는 기능을 구현하도록 강제`
    - 인터페이스는 구현을 강제할 메소드의 개수가 적을수록 좋다. (ISP - 인터페이스 분리 원칙)
    
> 리스코프 치환 원칙: 서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다. <br>
> 인터페이스 분리원칙: 쿨라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다.
> <br> <br> 
> 왜 그런지 같이 토론해보면 좋을 거 같습니다. P188

<br>

### `P126 같이 보기`

- `하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 생성된다.`

<br>

## `다형성: 사용편의성`

- 객체지향에서 다형성이라고 하면 `오버로딩`, `오버라이딩`이라고 할 수 있습니다.
- P131 메모리 구조 같이 보면 좋을 것 같습니다.
- [Effective Java - Item52](https://github.com/delicious-tangerine/effective-java/blob/master/8%EC%9E%A5/item52.md)

<br>

## `캡슐화: 정보 은닉`

- `P135, 접근지정자: private, protected, default, public`
- `protected가 자신과 상속 관계에 있는 서브 클래스만 접근 가능한 걸로 착각하는 경우가 많은데, 같은 패키지라면 접근 가능합니다.`
- `정적멤버 접근방법: 클래스명.정적멤버 로 접근해야 한다.`
    - `사람.인구, 고양이.다리개수` 형식으로 접근하는 것이 `홍길동.인구수, 키티.다리개수` 형식으로 접근하는 것보다 권장된다.
    
<br>

## `Java는 Call By Reference 일까 Call By Value 일까?`

```java
import java.util.ArrayList;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        List<String> listAugument = new ArrayList<>();
        listAugument.add("yaboong");

        printAndAdd(listAugument);
        listAugument.forEach(System.out::println);
    }

    private static void printAndAdd(List<String> listParam) {
        listParam.add("io");
        listParam = new ArrayList<>();
    }
}
```

